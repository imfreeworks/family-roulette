<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ã”ã¯ã‚“ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆï¼ˆé‡ã¿ï¼‹ä¿å­˜ï¼‰</title>
<style>
  body{font-family:system-ui;margin:0;background:#fafafa;text-align:center}
  h1{margin:14px 0 6px}
  .wrap{max-width:560px;margin:0 auto;padding:12px}
  .stage{position:relative;display:inline-block;margin-top:8px}
  canvas#wheel{
    background:#fff;border-radius:50%;
    box-shadow:0 10px 25px rgba(0,0,0,.12);
    touch-action:manipulation;
  }
  canvas#fx{position:absolute;left:0;top:0;pointer-events:none}
  .controls{margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;align-items:center}
  input,button,label{font-size:16px;padding:10px 12px}
  input{min-width:200px}
  button{cursor:pointer;border:1px solid #ddd;border-radius:12px;background:#fff}
  button.primary{background:#111;color:#fff;border-color:#111}
  button:disabled{opacity:.5;cursor:not-allowed}
  #result{margin:10px 0 0;font-size:26px;font-weight:800}
  #sub{margin-top:4px;color:#555;font-size:13px}
  .list{margin-top:12px;text-align:left;background:#fff;border:1px solid #eee;border-radius:14px;padding:10px}
  .list h2{margin:0 0 8px;font-size:14px;color:#555}
  .rows{display:grid;grid-template-columns:1fr auto auto auto;gap:6px 10px;align-items:center}
  .pill{border:1px solid #e5e5e5;background:#fafafa;border-radius:999px;padding:6px 10px;font-size:13px}
  .pop{animation: pop .6s ease both;}
  @keyframes pop{0%{transform:scale(.9)}60%{transform:scale(1.08)}100%{transform:scale(1)}}
</style>
</head>

<body>
<div class="wrap">
  <h1>ğŸ½ å®¶æ—ãƒ«ãƒ¼ãƒ¬ãƒƒãƒˆï¼ˆé‡ã¿ï¼æ‰‡å½¢ï¼‹ä¿å­˜ï¼‰</h1>

  <div class="stage">
    <canvas id="wheel" width="360" height="360"></canvas>
    <canvas id="fx" width="360" height="360"></canvas>
  </div>

  <div class="controls">
    <input id="item" placeholder="ä¾‹ï¼šã‚«ãƒ¬ãƒ¼">
    <button id="addBtn">è¿½åŠ </button>
    <button id="spinBtn" class="primary">ğŸ¯ å›ã™ï¼</button>
    <button id="delLastBtn">æœ€å¾Œå‰Šé™¤</button>
    <button id="resetBtn">åˆæœŸåŒ–</button>
  </div>

  <div class="controls" style="margin-top:6px;">
    <label class="pill">
      <input id="avoidRecentChk" type="checkbox" checked style="transform:scale(1.2); margin-right:8px;">
      æœ€è¿‘å‡ºãŸã‚„ã¤ã¯å‡ºã«ãã
    </label>
    <label class="pill">
      <input id="noRepeatChk" type="checkbox" checked style="transform:scale(1.2); margin-right:8px;">
      ç›´å‰ã«å½“ãŸã£ãŸã‚‚ã®ã¯æ¬¡å›å‡ºã•ãªã„
    </label>
  </div>

  <div id="result">â€”</div>
  <div id="sub">å€™è£œãƒ»é‡ã¿ãƒ»å±¥æ­´ã¯è‡ªå‹•ä¿å­˜ã•ã‚Œã¾ã™ï¼ˆãƒ–ãƒ©ã‚¦ã‚¶é–‰ã˜ã¦ã‚‚æ®‹ã‚‹ï¼‰</div>

  <div class="list">
    <h2>å€™è£œï¼ˆé‡ã¿ã‚’ï¼‹/âˆ’ã§èª¿æ•´ï¼‰</h2>
    <div class="rows" id="rows"></div>
    <div class="pill" style="margin-top:10px;">
      å±¥æ­´ï¼ˆæœ€æ–°5ï¼‰ï¼š<span id="hist">â€”</span>
    </div>
  </div>
</div>

<script>
/* ===========================
   æ°¸ç¶šåŒ–ã‚­ãƒ¼
=========================== */
const STORAGE_KEY = "family_roulette_weighted_v1";

/* åˆæœŸå€¤ï¼ˆä¿å­˜ãŒç„¡ã„ã¨ãã«ä½¿ã†ï¼‰ */
function defaultState(){
  return {
    items:   ["ã¾ã‚‹ãŒã‚ã›ã„ã‚ã‚“","ã‚¬ã‚¹ãƒˆ","ãƒãƒƒã‚¯","ãƒ”ã‚¶ãƒãƒƒãƒˆ","ã•ã°ã”ã¯ã‚“","ãƒã‚«ãƒ­ãƒ‹ã‚µãƒ©ãƒ€","ãŠã†ã¡ã§ãƒãƒ³ãƒãƒ¼ã‚°"],
    weights: [   3,        2,       4,      1,      2,        2 ,2],
    history: [],
    avoidRecent: true
  };
}

/* èª­ã¿è¾¼ã¿ï¼ˆå£Šã‚Œã¦ãŸã‚‰åˆæœŸå€¤ï¼‰ */
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return defaultState();
    const s = JSON.parse(raw);

    // æœ€ä½é™ã®æ•´å½¢ï¼ˆå‹ãŒå´©ã‚Œã¦ã‚‚å¾©æ—§ï¼‰
    const d = defaultState();
    s.items = Array.isArray(s.items) ? s.items.map(x=>String(x)) : d.items;
    s.weights = Array.isArray(s.weights) ? s.weights.map(x=>{
      const n = Number(x);
      return (isFinite(n) && n>0) ? n : 1;
    }) : d.weights;

    // é•·ã•åˆã‚ã›ï¼ˆç‰‡æ–¹ã ã‘å¢—æ¸›ã—ã¦ã¦ã‚‚ç›´ã™ï¼‰
    const L = Math.min(s.items.length, s.weights.length);
    s.items = s.items.slice(0, L);
    s.weights = s.weights.slice(0, L);
    if(L < 2){ s.items = d.items.slice(); s.weights = d.weights.slice(); }

    s.history = Array.isArray(s.history) ? s.history.map(x=>String(x)) : [];
    s.avoidRecent = (typeof s.avoidRecent === "boolean") ? s.avoidRecent : d.avoidRecent;
    return s;
  }catch{
    return defaultState();
  }
}

/* ä¿å­˜ï¼ˆå¤‰æ›´ã®ãŸã³ã«å‘¼ã¶ï¼‰ */
function saveState(){
  const s = { items, weights, history, avoidRecent: avoidRecentChk.checked };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
}

/* ===========================
   çŠ¶æ…‹
=========================== */
let { items, weights, history, avoidRecent } = loadState();

// æœ€è¿‘å‡ºãŸã‚‚ã®ã‚’å‡ºã«ãã
const HISTORY_LEN = 5;
const RECENT_DECAY = 0.6; // 0.8=ã‚†ã‚‹ã„ / 0.6=ãŠã™ã™ã‚ / 0.4=å¼·ã„

/* ===========================
   Canvas & UI
=========================== */
const canvas = document.getElementById("wheel");
const ctx = canvas.getContext("2d");
const fx = document.getElementById("fx");
const fctx = fx.getContext("2d");

const itemInput = document.getElementById("item");
const addBtn = document.getElementById("addBtn");
const spinBtn = document.getElementById("spinBtn");
const delLastBtn = document.getElementById("delLastBtn");
const resetBtn = document.getElementById("resetBtn");
const avoidRecentChk = document.getElementById("avoidRecentChk");
const resultEl = document.getElementById("result");
const subEl = document.getElementById("sub");
const rowsEl = document.getElementById("rows");
const histEl = document.getElementById("hist");
const noRepeatChk = document.getElementById("noRepeatChk");


avoidRecentChk.checked = avoidRecent;

let angle = 0;
let spinning = false;
let lastTickAt = 0;

/* ===========================
   éŸ³ï¼ˆWeb Audioï¼‰
=========================== */
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    audioCtx = new Ctx();
  }
  if (audioCtx.state === "suspended") audioCtx.resume();
}
function beep(freq, dur=0.06, type="square", gain=0.04) {
  if (!audioCtx) return;
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(gain, t + 0.008);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

  osc.connect(g); g.connect(audioCtx.destination);
  osc.start(t); osc.stop(t + dur + 0.01);
}
function tickSound() { beep(900 + Math.random()*120, 0.04, "square", 0.03); }
function winSound() {
  beep(523.25, 0.10, "triangle", 0.06);
  setTimeout(()=>beep(659.25, 0.10, "triangle", 0.06), 120);
  setTimeout(()=>beep(783.99, 0.14, "triangle", 0.06), 240);
}

/* ===========================
   é‡ã¿ã‹ã‚‰æ‰‡å½¢
=========================== */
function buildSegments(baseWeights) {
  const safe = baseWeights.map(w => {
    const n = Number(w);
    return (isFinite(n) && n > 0) ? n : 1;
  });
  const sum = safe.reduce((a,b)=>a+b,0);
  let cur = 0;
  const segs = [];
  for (let i=0;i<items.length;i++){
    const span = (safe[i]/sum) * 2*Math.PI;
    const start = cur, end = cur + span;
    segs.push({ name: items[i], w: safe[i], start, end });
    cur = end;
  }
  return segs;
}

function effectiveWeights() {
  const n = items.length;

  // ã¾ãšãƒ™ãƒ¼ã‚¹é‡ã¿
  let eff = weights.map(w => {
    const base = Number(w);
    return (isFinite(base) && base > 0) ? base : 1;
  });

  // ã€Œæœ€è¿‘å‡ºãŸã‚„ã¤ã¯å‡ºã«ããã€(æ—¢å­˜ã®ä»•æ§˜)
  if (avoidRecentChk.checked) {
    const recent = history.slice(0, HISTORY_LEN);
    const counts = new Map();
    for (const x of recent) counts.set(x, (counts.get(x) || 0) + 1);

    eff = eff.map((base, i) => {
      const name = items[i];
      const c = counts.get(name) || 0;
      return base * Math.pow(RECENT_DECAY, c);
    });
  }

  // â˜…è¿½åŠ ï¼šç›´å‰ã«å½“ãŸã£ãŸã‚‚ã®ã¯æ¬¡å›ã€Œçµ¶å¯¾å‡ºãªã„ã€
  if (noRepeatChk.checked && history.length > 0 && n >= 2) {
    const last = history[0];
    eff = eff.map((w, i) => (items[i] === last ? 0 : w));
    // å…¨éƒ¨0ã«ãªã‚‹äº‹æ•…å›é¿ï¼ˆå€™è£œ1ã¤ã¨ã‹ã€å…¨éƒ¨åŒã˜åå‰ã¨ã‹ï¼‰
    const sum = eff.reduce((a,b)=>a+b,0);
    if (sum <= 0) {
      eff = weights.map(w => (Number(w) > 0 ? Number(w) : 1));
    }
  }

  return eff;
}


/* ===========================
   æç”»
=========================== */
function drawWheel(){
  const r = canvas.width/2;
  const cx = r, cy = r;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const segs = buildSegments(effectiveWeights());

  for (let i=0;i<segs.length;i++){
    const seg = segs[i];
    const start = angle + seg.start;
    const end   = angle + seg.end;

    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.arc(cx,cy,r-2,start,end);
    ctx.closePath();
    ctx.fillStyle = `hsl(${(i*360/segs.length)|0}, 82%, 72%)`;
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,.10)";
    ctx.stroke();

    const mid = (start + end)/2;
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(mid);
    ctx.textAlign = "right";
    ctx.fillStyle = "rgba(0,0,0,.78)";
    ctx.font = "15px system-ui";
    ctx.fillText(seg.name, r-18, 6);
    ctx.restore();
  }

  // ä¸­å¿ƒ
  ctx.beginPath();
  ctx.arc(cx,cy,18,0,2*Math.PI);
  ctx.fillStyle = "rgba(255,255,255,.9)";
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,.10)";
  ctx.stroke();

  // çŸ¢å°ï¼ˆä¸Šï¼‰
  ctx.fillStyle = "#e11";
  ctx.beginPath();
  ctx.moveTo(cx-14, 8);
  ctx.lineTo(cx+14, 8);
  ctx.lineTo(cx, 30);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = "rgba(0,0,0,.12)";
  ctx.stroke();
}

function renderRows(){
  rowsEl.innerHTML = "";
  for (let i=0;i<items.length;i++){
    const name = document.createElement("div");
    name.className = "pill";
    name.textContent = items[i];

    const w = document.createElement("div");
    w.className = "pill";
    w.textContent = String(weights[i]);

    const minus = document.createElement("button");
    minus.textContent = "âˆ’";
    minus.title = "é‡ã¿ã‚’ä¸‹ã’ã‚‹";
    minus.onclick = () => {
      weights[i] = Math.max(1, Number(weights[i]||1) - 1);
      saveState(); // â†ä¿å­˜
      renderRows();
      drawWheel();
    };

    const plus = document.createElement("button");
    plus.textContent = "ï¼‹";
    plus.title = "é‡ã¿ã‚’ä¸Šã’ã‚‹";
    plus.onclick = () => {
      weights[i] = Math.min(99, Number(weights[i]||1) + 1);
      saveState(); // â†ä¿å­˜
      renderRows();
      drawWheel();
    };

    rowsEl.appendChild(name);
    rowsEl.appendChild(w);
    rowsEl.appendChild(minus);
    rowsEl.appendChild(plus);
  }

  histEl.textContent = history.length ? history.slice(0,5).join(" / ") : "â€”";
}

/* ===========================
   å½“é¸åˆ¤å®š
=========================== */
function pickByPointer(){
  const pointerWorld = -Math.PI/2;
  let a = (pointerWorld - angle) % (2*Math.PI);
  if (a < 0) a += 2*Math.PI;

  const segs = buildSegments(effectiveWeights());
  for (const seg of segs){
    if (a >= seg.start && a < seg.end) return seg.name;
  }
  return segs[segs.length-1].name;
}

function snapAngleToWinner(winnerName){
  const pointerWorld = -Math.PI/2;
  const segs = buildSegments(effectiveWeights());
  const seg = segs.find(s => s.name === winnerName) || segs[0];
  const midInternal = (seg.start + seg.end)/2;
  angle = pointerWorld - midInternal;
  const span = (seg.end - seg.start);
  angle += (Math.random()-0.5) * span * 0.08;
}

function weightedRandomName(){
  const eff = effectiveWeights().map(w => (isFinite(w) && w>0) ? w : 1);
  const sum = eff.reduce((a,b)=>a+b,0);
  let r = Math.random() * sum;
  for (let i=0;i<items.length;i++){
    r -= eff[i];
    if (r <= 0) return items[i];
  }
  return items[items.length-1];
}

/* ===========================
   ç´™å¹é›ª
=========================== */
let confetti = [];
function spawnConfetti(){
  confetti = [];
  const W = fx.width, H = fx.height;
  const N = 120;
  for (let i=0;i<N;i++){
    confetti.push({
      x: W/2 + (Math.random()-0.5)*40,
      y: H/2 + (Math.random()-0.5)*40,
      vx: (Math.random()-0.5)*6,
      vy: -Math.random()*6 - 2,
      g: 0.12 + Math.random()*0.10,
      size: 4 + Math.random()*5,
      rot: Math.random()*Math.PI,
      vr: (Math.random()-0.5)*0.25,
      hue: Math.random()*360,
      life: 110 + (Math.random()*50|0),
    });
  }
  requestAnimationFrame(animateConfetti);
}
function animateConfetti(){
  fctx.clearRect(0,0,fx.width,fx.height);
  confetti.forEach(p => {
    p.vy += p.g; p.x += p.vx; p.y += p.vy; p.rot += p.vr; p.life--;
    fctx.save();
    fctx.translate(p.x, p.y);
    fctx.rotate(p.rot);
    fctx.fillStyle = `hsl(${p.hue}, 90%, 60%)`;
    fctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.7);
    fctx.restore();
  });
  confetti = confetti.filter(p => p.life > 0 && p.y < fx.height + 40);
  if (confetti.length) requestAnimationFrame(animateConfetti);
  else fctx.clearRect(0,0,fx.width,fx.height);
}

/* ===========================
   æ“ä½œï¼ˆâ€»å…¨éƒ¨ saveState() ã™ã‚‹ï¼‰
=========================== */
function addItem(){
  const v = itemInput.value.trim();
  if (!v) return;
  items.push(v);
  weights.push(1);
  itemInput.value = "";
  resultEl.textContent = "â€”";
  subEl.textContent = "å€™è£œè¿½åŠ ï¼ˆé‡ã¿=1ï¼‰";
  saveState(); // â†ä¿å­˜
  drawWheel(); renderRows();
}

function delLast(){
  if (items.length <= 2) { subEl.textContent = "å€™è£œã¯2ã¤ä»¥ä¸Šã‚ã‚‹ã¨æ¥½ã—ã„ã‚ˆï¼"; return; }
  items.pop(); weights.pop();
  resultEl.textContent = "â€”";
  subEl.textContent = "æœ€å¾Œã®å€™è£œã‚’å‰Šé™¤";
  saveState(); // â†ä¿å­˜
  drawWheel(); renderRows();
}

function resetItems(){
  const d = defaultState();
  items = d.items.slice();
  weights = d.weights.slice();
  history = [];
  avoidRecentChk.checked = d.avoidRecent;
  angle = 0;
  resultEl.textContent = "â€”";
  subEl.textContent = "åˆæœŸåŒ–ã—ãŸã‚ˆï¼ˆä¿å­˜ã‚‚åˆæœŸåŒ–ï¼‰";
  saveState(); // â†ä¿å­˜
  drawWheel(); renderRows();
}

function spin(){
  if (spinning) return;
  if (items.length < 2) { subEl.textContent = "å€™è£œã‚’2ã¤ä»¥ä¸Šå…¥ã‚Œã¦ã­ï¼"; return; }

  ensureAudio();
  spinning = true;
  spinBtn.disabled = addBtn.disabled = delLastBtn.disabled = resetBtn.disabled = true;

  resultEl.textContent = "â€¦";
  subEl.textContent = "ã„ãã‚ˆï¼";
  resultEl.classList.remove("pop");

  const plannedWinner = weightedRandomName();

  let speed = 0.55 + Math.random()*0.30;
  const friction = 0.985;
  const minSpeed = 0.0025;
  const startTime = performance.now();
  const minSpinMs = 1600 + Math.random()*600;

  function frame(t){
    angle += speed;
    speed *= friction;

    const now = performance.now();
    if (speed > 0.02 && now - lastTickAt > 70) { tickSound(); lastTickAt = now; }

    drawWheel();

    const elapsed = t - startTime;
    if (elapsed < minSpinMs || speed > minSpeed){
      requestAnimationFrame(frame);
    } else {
      finishSpin(plannedWinner);
    }
  }
  requestAnimationFrame(frame);
}

function finishSpin(plannedWinner){
  snapAngleToWinner(plannedWinner);
  drawWheel();

  const winner = pickByPointer();

  history.unshift(winner);
  history = history.slice(0, 30);

  saveState(); // â†å±¥æ­´ã‚‚ä¿å­˜ï¼

  winSound();
  spawnConfetti();

  resultEl.textContent = `âœ… ${winner} ã«æ±ºå®šï¼`;
  resultEl.classList.add("pop");
  subEl.textContent = "ä¿å­˜ã•ã‚Œã‚‹ã®ã§ã€é–‰ã˜ã¦ã‚‚æ¬¡å›ãã®ã¾ã¾ç¶šãã¾ã™";

  spinning = false;
  spinBtn.disabled = addBtn.disabled = delLastBtn.disabled = resetBtn.disabled = false;
}

/* ===========================
   ã‚¤ãƒ™ãƒ³ãƒˆ
=========================== */
addBtn.addEventListener("click", addItem);
itemInput.addEventListener("keydown", (e)=>{ if(e.key==="Enter") addItem(); });
spinBtn.addEventListener("click", spin);
delLastBtn.addEventListener("click", delLast);
resetBtn.addEventListener("click", resetItems);
avoidRecentChk.addEventListener("change", ()=>{
  saveState();      // â†è¨­å®šã‚‚ä¿å­˜
  drawWheel();
});
noRepeatChk.addEventListener("change", ()=>{
  saveState();
  drawWheel();
});


/* åˆæœŸæç”»ï¼ˆä¿å­˜çŠ¶æ…‹ã‚’åæ˜ ï¼‰ */
drawWheel();
renderRows();
saveState(); // åˆå›èµ·å‹•ã§æ•´å½¢å¾Œã®çŠ¶æ…‹ã‚’ä¿å­˜
</script>
</body>
</html>
